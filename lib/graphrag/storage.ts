import { createClient } from '@/lib/supabase/server'
import { GeneratedQuestion } from './generate'
import { QuestionFormat } from './prompts'
import type { SupabaseClient } from '@supabase/supabase-js'
import type { Database } from '@/lib/types/database'

/**
 * Stored Question (matches Supabase schema)
 */
export interface StoredQuestion {
  id: string
  topic_id: string | null
  bloom_level: number
  question_text: string
  question_type: string
  question_format: string
  options: any
  correct_answer: string | null
  correct_answers: string[] | null
  explanation: string
  rag_context: string | null
  difficulty_level: string | null
  times_used: number
  avg_correctness_rate: number | null
  source_type: string
  user_id: string | null
  created_at: string
  updated_at: string

  // GraphRAG-specific metadata
  entity_id: string
  entity_name: string
  domain: string
  full_path: string
  tokens_used: number
  generation_cost: number
  model: string
}

/**
 * Storage result
 */
export interface StorageResult {
  success: boolean
  questionId?: string
  error?: string
  isDuplicate?: boolean
}

/**
 * Calculate difficulty level based on Bloom level and format
 */
function calculateDifficultyLevel(bloomLevel: number, format: QuestionFormat): string {
  if (bloomLevel <= 2 && format === 'mcq_single') {
    return 'easy'
  } else if (bloomLevel <= 3 || format === 'mcq_multi' || format === 'fill_blank') {
    return 'medium'
  } else {
    return 'hard'
  }
}

/**
 * Calculate generation cost
 */
function calculateCost(inputTokens: number, outputTokens: number): number {
  // Claude Sonnet 4 pricing: $3/M input, $15/M output
  return (inputTokens * 3 / 1000000) + (outputTokens * 15 / 1000000)
}

/**
 * Store generated question in Supabase
 *
 * @param question - Generated question from Claude
 * @param topicId - Optional Supabase topic ID (if linking to existing topic)
 * @param userId - Optional user ID (if generated by specific user)
 * @param client - Optional Supabase client (for scripts, use createScriptClient())
 * @returns Storage result with question ID
 */
export async function storeGeneratedQuestion(
  question: GeneratedQuestion,
  topicId?: string,
  userId?: string,
  client?: SupabaseClient<Database>
): Promise<StorageResult> {
  try {
    const supabase = client || await createClient()

    // Check for duplicates (same question text for same entity)
    const { data: existing, error: checkError } = await supabase
      .from('questions')
      .select('id')
      .eq('question_text', question.question)
      .eq('entity_id', question.entityId)
      .maybeSingle()

    if (checkError) {
      console.error('Error checking for duplicates:', checkError)
      return { success: false, error: checkError.message }
    }

    if (existing) {
      // Log removed
      return { success: true, questionId: existing.id, isDuplicate: true }
    }

    // Calculate metadata
    const difficultyLevel = calculateDifficultyLevel(question.bloomLevel, question.format)
    const generationCost = calculateCost(question.tokensUsed.input, question.tokensUsed.output)

    // Prepare data for insertion
    const questionData = {
      topic_id: topicId || null,
      bloom_level: question.bloomLevel,
      question_text: question.question,
      question_type: mapFormatToType(question.format),
      question_format: question.format,
      options: question.options || null,
      correct_answer: question.correctAnswer || null,
      correct_answers: question.correctAnswers || null,
      explanation: question.explanation,
      rag_context: JSON.stringify({
        entityId: question.entityId,
        entityName: question.entityName,
        domain: question.domain,
        fullPath: question.fullPath
      }),
      difficulty_level: difficultyLevel,
      times_used: 0,
      avg_correctness_rate: null,
      source_type: 'ai_generated_graphrag',
      user_id: userId || null,

      // GraphRAG metadata (stored in JSONB columns or separate fields)
      entity_id: question.entityId,
      entity_name: question.entityName,
      domain: question.domain,
      full_path: question.fullPath,
      tokens_used: question.tokensUsed.total,
      generation_cost: generationCost,
      model: question.model
    }

    // Insert question
    const { data, error } = await supabase
      .from('questions')
      .insert(questionData)
      .select('id')
      .single()

    if (error) {
      console.error('Error storing question:', error)
      return { success: false, error: error.message }
    }

    // Log removed
    return { success: true, questionId: data.id, isDuplicate: false }

  } catch (error: any) {
    console.error('Unexpected error storing question:', error)
    return { success: false, error: error.message }
  }
}

/**
 * Map question format to question type
 */
function mapFormatToType(format: QuestionFormat): string {
  switch (format) {
    case 'mcq_single':
    case 'mcq_multi':
      return 'multiple_choice'
    case 'fill_blank':
      return 'fill_in_blank'
    case 'open_ended':
      return 'short_answer'
    default:
      return 'multiple_choice'
  }
}

/**
 * Batch store multiple questions
 *
 * @param questions - Array of generated questions
 * @param topicId - Optional topic ID
 * @param userId - Optional user ID
 * @param client - Optional Supabase client (for scripts, use createScriptClient())
 * @returns Array of storage results
 */
export async function batchStoreQuestions(
  questions: GeneratedQuestion[],
  topicId?: string,
  userId?: string,
  client?: SupabaseClient<Database>
): Promise<StorageResult[]> {
  const results: StorageResult[] = []

  for (const question of questions) {
    const result = await storeGeneratedQuestion(question, topicId, userId, client)
    results.push(result)

    // Small delay to avoid overwhelming database
    await new Promise(resolve => setTimeout(resolve, 100))
  }

  const successCount = results.filter(r => r.success && !r.isDuplicate).length
  const duplicateCount = results.filter(r => r.isDuplicate).length
  const errorCount = results.filter(r => !r.success).length

  // Log removed

  return results
}

/**
 * Get questions by entity ID
 *
 * @param entityId - UUID of curriculum entity
 * @param bloomLevel - Optional filter by Bloom level
 * @param format - Optional filter by format
 * @param limit - Maximum results (default: 50)
 * @returns Array of stored questions
 */
export async function getQuestionsByEntity(
  entityId: string,
  bloomLevel?: number,
  format?: QuestionFormat,
  limit: number = 50
): Promise<StoredQuestion[]> {
  const supabase = await createClient()

  let query = supabase
    .from('questions')
    .select('*')
    .eq('entity_id', entityId)
    .order('created_at', { ascending: false })
    .limit(limit)

  if (bloomLevel) {
    query = query.eq('bloom_level', bloomLevel)
  }

  if (format) {
    query = query.eq('question_format', format)
  }

  const { data, error } = await query

  if (error) {
    console.error('Error fetching questions:', error)
    return []
  }

  return data || []
}

/**
 * Get questions by domain
 *
 * @param domain - Domain name
 * @param bloomLevel - Optional filter by Bloom level
 * @param limit - Maximum results (default: 100)
 * @returns Array of stored questions
 */
export async function getQuestionsByDomain(
  domain: string,
  bloomLevel?: number,
  limit: number = 100
): Promise<StoredQuestion[]> {
  const supabase = await createClient()

  let query = supabase
    .from('questions')
    .select('*')
    .eq('domain', domain)
    .order('created_at', { ascending: false })
    .limit(limit)

  if (bloomLevel) {
    query = query.eq('bloom_level', bloomLevel)
  }

  const { data, error } = await query

  if (error) {
    console.error('Error fetching questions:', error)
    return []
  }

  return data || []
}

/**
 * Update question usage stats
 *
 * @param questionId - Question ID
 * @param wasCorrect - Whether answer was correct
 */
export async function updateQuestionStats(
  questionId: string,
  wasCorrect: boolean
): Promise<void> {
  const supabase = await createClient()

  // Get current stats
  const { data: question, error: fetchError } = await supabase
    .from('questions')
    .select('times_used, avg_correctness_rate')
    .eq('id', questionId)
    .single()

  if (fetchError || !question) {
    console.error('Error fetching question for stats update:', fetchError)
    return
  }

  const timesUsed = question.times_used + 1
  const currentRate = question.avg_correctness_rate || 0
  const newRate = ((currentRate * question.times_used) + (wasCorrect ? 1 : 0)) / timesUsed

  // Update stats
  const { error: updateError } = await supabase
    .from('questions')
    .update({
      times_used: timesUsed,
      avg_correctness_rate: newRate,
      updated_at: new Date().toISOString()
    })
    .eq('id', questionId)

  if (updateError) {
    console.error('Error updating question stats:', updateError)
  }
}
